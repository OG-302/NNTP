package org.anarplex.lib.nntp;

import org.apache.commons.lang3.StringUtils;

import java.io.Reader;
import java.util.*;

public class Spec {

    private Spec() {
        super();
    }

    public enum NNTP_Request_Commands {
        ARTICLE,
        BODY,
        CAPABILITIES,
        DATE,
        GROUP,
        HEAD,
        HELP,
        IHAVE,
        LAST,
        LIST,
        LISTGROUP,
        MODE,
        NEWGROUPS,
        NEWNEWS,
        NEXT,
        OVERVIEW,
        POST,
        QUIT,
        STAT,
        XOVER,
    }

    public enum NNTP_Response_Code {
        Code_100(100), // Generated by: HELP.  Meaning: help text follows.
        Code_101(101), // Generated by: CAPABILITIES.  Meaning: capabilities list follows.
        Code_111(111), // Generated by: DATE.  articles.ddl argument: yyyymmddhhmmss.  Meaning: server date and time.
        Code_200(200), // Generated by: initial connection, MODE READER.  Meaning: service available, posting allowed.
        Code_201(201), // Generated by: initial connection, MODE READER.  Meaning: service available, posting prohibited.
        Code_205(205), // Generated by: QUIT.  Meaning: connection closing (the server immediately closes the connection).
        Code_211(211), // Generated either by: GROUP with 4 arguments (number low high group) meaning: group selected, or (multi-line) by: LISTGROUP with 4 arguments (number low high group) meaning: article numbers follow.
        Code_215(215), // Generated by: LIST.  Meaning: information follows.
        Code_220(220), // Generated by: ARTICLE msgs.ddl arguments: n message-id.  Meaning: article follows.
        Code_221(221), // Generated by: HEAD.  msgs.ddl arguments: n message-id.  Meaning: article headers follow.
        Code_222(222), // Generated by: BODY.  msgs.ddl arguments: n message-id.  Meaning: article body follows.
        Code_223(223), // Generated by: LAST, NEXT, STAT.  msgs.ddl arguments: n message-id.  Meaning: article exists and selected.
        Code_224(224), // Generated by: OVER.  Meaning: overview information follows.
        Code_225(225), // Generated by: HDR.  Meaning: headers follow.
        Code_230(230), // Generated by: NEWNEWS.  Meaning: list of new articles follows.
        Code_231(231), // Generated by: NEWGROUPS.  Meaning: list of new newsgroups follows.
        Code_235(235), // Generated by: IHAVE (second stage).  Meaning: article transferred OK.
        Code_240(240), // Generated by: POST (second stage).  Meaning: article received OK.
        Code_281(281), // Successful authentication using the AUTHINFO command extension.
        Code_335(335), // Generated by: IHAVE (first stage) Meaning: send article to be transferred
        Code_340(340), // Generated by: POST (first stage) Meaning: send article to be posted.
        Code_381(381), // RFC-2980: More authentication information required
        Code_400(400), // Generic response and generated by initial connection. Meaning: service not available or no longer available (the server immediately closes the connection).
        Code_403(403), // Generic response. Meaning: internal fault or problem preventing action being taken.
        Code_411(411), // Generated by: GROUP, LISTGROUP. Meaning: no such newsgroup.
        Code_412(412), // Generated by: ARTICLE, BODY, GROUP, HDR, HEAD, LAST, LISTGROUP, NEXT, OVER, STAT.  Meaning: no newsgroup selected.
        Code_420(420), // Generated by: ARTICLE, BODY, HDR, HEAD, LAST, NEXT, OVER, STAT.  Meaning: current article number is invalid.
        Code_421(421), // Generated by: NEXT.  Meaning: no next article in this group.
        Code_422(422), // Generated by: LAST.  Meaning: no previous article in this group.
        Code_423(423), // Generated by: ARTICLE, BODY, HDR, HEAD, OVER, STAT.  Meaning: no article with that number or in that range.
        Code_430(430), // Generated by: ARTICLE, BODY, HDR, HEAD, OVER, STAT.  Meaning: no article with that message-id.
        Code_435(435), // Generated by: IHAVE (first stage).  Meaning: article not wanted.
        Code_436(436), // Generated by: IHAVE (either stage).  Meaning: transfer not possible (first stage) or failed (second stage); try again later.
        Code_437(437), // Generated by: IHAVE (second stage).  Meaning: transfer rejected; do not retry.
        Code_440(440), // Generated by: POST (first stage).  Meaning: posting not permitted.
        Code_441(441), // Generated by: POST (second stage).  Meaning: posting failed.
        Code_480(480), // Generic response.  Meaning: command unavailable until the client has authenticated itself.
        Code_481(481), // RFC-4643: Authentication failed/rejected
        Code_482(482), // RFC-2980: Authentication rejected.  RFC-4643: Authentication commands issued out of sequence
        Code_483(483), // Generic response.  Meaning: command unavailable until suitable privacy has been arranged.
        Code_500(500), // Generic response.  Meaning: unknown command.
        Code_501(501), // Generic response.  Meaning: syntax error in command.
        Code_502(502), // Generic response and generated by initial connection.  Meaning for the initial connection and the MODE READER command: service permanently unavailable (the server immediately closes the connection).  Meaning for all other commands: command not permitted (and there is no way for the client to change this).
        Code_503(503), // Generic response.  Meaning: feature not supported.
        Code_504(504);  // Generic response.  Meaning: error in base64-encoding [RFC4648] of an argument

        private final int value;

        NNTP_Response_Code(int value) {
            this.value = value;
        }

        public int getValue() {
            return value;
        }

        public String toString() {
            return Integer.toString(value);
        }
    }


    public enum NNTP_Response_Commands {

    }

    public enum NNTP_Standard_Article_Headers {
        // mandatory headers for every article
        MessageID("Message-Id"),
        Date("Date"),
        From("From"),
        Newsgroups("Newsgroups"),
        Path("Path"),
        Subject("Subject"),
        // optional standardized headers for every article
        References("References"),
        Bytes(":bytes"),
        Lines(":lines");

        private final String value;

        NNTP_Standard_Article_Headers(String value) {
            this.value = value;
        }

        public String toString() {
            return value;
        }

        public String getValue() {
            return value;
        }

        public boolean isOptional() {
            return this == NNTP_Standard_Article_Headers.Bytes || this == NNTP_Standard_Article_Headers.Lines || this == NNTP_Standard_Article_Headers.References;
        }

        public static boolean contains(String v) {
            return EnumSet.allOf(NNTP_Standard_Article_Headers.class).stream().anyMatch(e -> e.getValue().equals(v));
        }
    }

    /**
     * Newsgroup name.
     *
     * All newsgroup names are case-insensitive and are converted to lower case.
     *
     * @param
     */
    public static class NewsgroupName {
        private final static int NewsgroupNameMaxLen = 1024;  // (practical limit.  not from spec)
        private final String name;

        public static class InvalidNewsgroupNameException extends Exception {
            public InvalidNewsgroupNameException(String message) {
                super(message);
            }
        }

        @Override
        public final boolean equals(Object o) {
            if (!(o instanceof NewsgroupName that)) return false;

            return name.equals(that.name);
        }

        @Override
        public int hashCode() {
            return name.hashCode();
        }

        /**
         * Create a new NewsgroupName.  Throws an IllegalArgumentException if the name is invalid.
         *
         * @param name
         */
        public NewsgroupName(String name) throws InvalidNewsgroupNameException {
            if (isValid(name)) {
                this.name = name.toLowerCase(); // convert to lower case
            } else {
                throw new InvalidNewsgroupNameException("Invalid newsgroup name: " + name);
            }
        }

        public String getValue() {
            return name;
        }

        @Override
        public String toString() { return getValue();}

        /**
         * Check if the name is valid.
         * According to RFC 3977, a newsgroup name must consist of dot-separated components,
         * where each component contains one or more letters, digits, hyphens (-), plus signs (+), or underscores (_).
         * Also, there must be at least one component, and the maximum length of the name is 1024 characters.
         *
         * @param name
         * @return
         */
        public static boolean isValid(String name) {
            return name != null
                    && !name.isEmpty()
                    && name.length() <= NewsgroupNameMaxLen
                    && name.charAt(0) != '.'                    // does not start with a dot
                    && name.charAt(name.length() - 1) != '.'    // does not end with a dot
                    && !name.contains("..")                     // does not contain two consecutive dots
                    && name.matches("^[a-zA-Z0-9\\-+_.]+$");
        }
    }

    public enum PostingMode {
        Prohibited(0),
        Allowed(1),
        Moderated(2);

        private final int value;

        PostingMode(final int value) {
            this.value = value;
        }

        public static PostingMode valueOf(int anInt) {
            return Arrays.stream(PostingMode.values())
                    .filter(v -> v.getValue() == anInt)
                    .findFirst()
                    .orElseThrow(() -> new IllegalArgumentException("Invalid PostingMode: " + anInt));
        }

        public int getValue() {
            return value;
        }

        public String toString() {
            return  Integer.toString(getValue());
        }
    }

    public static class MessageId {
        private final static int MessageIdMaxLen = 250;
        private final String messageId;

        static public class InvalidMessageIdException extends Exception {
            public InvalidMessageIdException(String message) {
                super(message);
            }
        }

        public MessageId(String messageId) throws InvalidMessageIdException {
            if (isValid(messageId)) {
                this.messageId = messageId;
            } else {
                throw new InvalidMessageIdException("Invalid message id: " + messageId);
            }
        }

        public String getValue() {
            return messageId;
        }

        public String toString() {
            return getValue();
        }

        @Override
        public final boolean equals(Object o) {
            if (!(o instanceof MessageId messageId1)) return false;

            return messageId.equals(messageId1.messageId);
        }

        @Override
        public int hashCode() {
            return messageId.hashCode();
        }



        public static boolean isValid(String id) {
            return id != null &&
                    id.length() >= 3 &&
                    id.length() <= MessageIdMaxLen &&
                    id.indexOf('<') == 0 && // the first character is the opening delimiter
                    id.indexOf('>') == id.length() - 1 &&  // the closing delimiter is found only at the end of the id
                    StringUtils.isAsciiPrintable(id);   // all characters must be printable ASCII
        }
    }

    public static class ArticleNumber {
        final int number;

        static public class InvalidArticleNumberException extends Exception {
            public InvalidArticleNumberException(String message) {
                super(message);
            }
        }

        public ArticleNumber(int number) throws InvalidArticleNumberException {
            this.number = number;
            if (!isValid(number)) {
                throw new InvalidArticleNumberException("Invalid article number: " + number);
            }
        }

        public int getValue() {
            return this.number;
        }

        public static boolean isValid(int number) {
            return 1 <= number || number == NoArticlesLowestNumber || number == NoArticlesHighestNumber;
        }

        @Override
        public final boolean equals(Object o) {
            if (!(o instanceof ArticleNumber that)) return false;

            return number == that.number;
        }

        @Override
        public int hashCode() {
            return number;
        }

        @Override
        public String toString() { return Integer.toString(getValue()); }
    }

    // The lowest number to be returned when a newsgroup does not have any articles.  MUST be less than 1.
    final static int NoArticlesLowestNumber = 0;    // by NNTP convention this value is 0 but that choice not mandatory
    // The highest number to be returned when a newsgroup does not have any articles.  MUST be less than 0.
    final static int NoArticlesHighestNumber = -1;  // by NNTP convention this value is -1 but that choice not mandatory

    public static class NoArticlesLowestNumber extends ArticleNumber {
        private NoArticlesLowestNumber() throws InvalidArticleNumberException {
            super(NoArticlesLowestNumber);
        }
        public static NoArticlesLowestNumber getInstance() {
            NoArticlesLowestNumber result = null;
            try {
                result = new NoArticlesLowestNumber();
            } catch (InvalidArticleNumberException e) {
                // its not wrong when we do it :)
            }
            return result;
        }
    }

    public static class NoArticlesHighestNumber extends ArticleNumber {
        private NoArticlesHighestNumber() throws InvalidArticleNumberException {
            super(NoArticlesHighestNumber);
        }
        public static NoArticlesHighestNumber getInstance() {
            NoArticlesHighestNumber result = null;
            try {
                result = new NoArticlesHighestNumber();
            } catch (InvalidArticleNumberException e) {
                // its not wrong when we do it :)
            }
            return result;
        }
    }

    public static abstract class Article {

        public abstract Reader getBody();
        public abstract ArticleHeaders getAllHeaders();

        public static boolean isInvalidBody(String body) {
            return body == null || body.isEmpty();
        }

        private MessageId getMessageId() {
            try {
                return new MessageId(
                        getAllHeaders().getHeaderValue(NNTP_Standard_Article_Headers.MessageID.getValue()).iterator().next());
            } catch (MessageId.InvalidMessageIdException e) {
                throw new RuntimeException(e);
            }
        }

        @Override
        public int hashCode() {
            return getMessageId().hashCode();
        }

        @Override
        public boolean equals(Object obj) {
            return getMessageId().equals(obj);
        }

        public static class ArticleHeaders {
            private final Map<String, Set<String>> headerFields;

            public static class InvalidArticleHeaderException extends Exception {
                public InvalidArticleHeaderException(String message) {
                    super(message);
                }
            }

            public ArticleHeaders(Map<String, Set<String>> headerFields) throws InvalidArticleHeaderException {
                this.headerFields = validateHeaderFields(headerFields);
            }

            public Iterable<? extends Map.Entry<String, Set<String>>> entrySet() {
                return Set.copyOf(headerFields.entrySet());
            }

            public Set<String> getHeaderValue(String headerName) {
                return (headerFields.containsKey(headerName) ? Set.copyOf(headerFields.get(headerName)) : null);
            }

            /**
             * Check if the header fields are valid.  A valid header field set MUST contain all of the Standard Article Headers,
             * and those fields MUST be valid according to the various methods defined below.  As for non-standard headers,
             * those must conform to basic syntax and formatting rules (see also below).
             * This method will return a normalised version of the header fields. i.e. one where a multivalued
             * Newgroup header value (such as "group1, group2") is converted to a set of single valued entries.
             *
             * @param headerFields
             * @return normalised header fields where each value is properly normalised according to the field type
             */
            public static Map<String, Set<String>> validateHeaderFields(Map<String, Set<String>> headerFields)
                throws InvalidArticleHeaderException {
                if (headerFields != null) {
                    EnumSet<NNTP_Standard_Article_Headers> stdArticlesHeaderSet = EnumSet.allOf(NNTP_Standard_Article_Headers.class);

                    for (NNTP_Standard_Article_Headers header : stdArticlesHeaderSet) {
                        if (!header.isOptional() && !headerFields.containsKey(header.getValue())) {
                            throw new InvalidArticleHeaderException("Missing required header field: " + header.getValue());
                        }
                    }

                    // break multivalued header fields into sets of single values
                    for (Map.Entry<String, Set<String>> entry : headerFields.entrySet()) {
                        if (entry.getKey().equals(NNTP_Standard_Article_Headers.Newsgroups.getValue())) {
                            // newsgroups is a special case because it is a multivalued header field that must be a set of newsgroup names
                            Set<String> newsgroups = new HashSet<>();
                            for (String v : entry.getValue()) {
                                String[] namesList = v.split(",");
                                for (String name : namesList) {
                                    newsgroups.add(name);
                                }
                                headerFields.put(entry.getKey(), newsgroups);
                            }
                        }
                    }

                    for (Map.Entry<String, Set<String>> e : headerFields.entrySet()) {
                        if (!isValidHeaderField(e.getKey(), e.getValue())) {
                            throw new InvalidArticleHeaderException("Invalid header field: " + e.getKey());
                        }
                    }
                }
                return headerFields;
            }

            public static boolean isValidHeaderField(String name, Set<String> value) {
                if (isValidHeaderName(name)) {
                    if (value == null) {
                        value = new HashSet<>();
                    }
                    // the form of the header name in general is valid.  Now check the specific cases
                    // of the standardized headers.
                    if (name.equalsIgnoreCase(NNTP_Standard_Article_Headers.MessageID.getValue())) {
                        return value.size() == 1 && MessageId.isValid(value.iterator().next());
                    } else if (name.equalsIgnoreCase(NNTP_Standard_Article_Headers.Newsgroups.getValue())) {
                        for (String v : value) {
                            if (!NewsgroupName.isValid(v)) {
                                return false;
                            }
                        }
                    } else if (name.equalsIgnoreCase(NNTP_Standard_Article_Headers.Subject.getValue())) {
                        if (value.size() == 1) {
                            // The Subject header value is not constrained.  It may contain any characters.
                            return isValidUnstructuredValue(value.iterator().next());
                        } else {
                            return false;
                        }
                    } else if (name.equalsIgnoreCase(NNTP_Standard_Article_Headers.Date.getValue())) {
                        if (value.size() == 1) {
                            return isValidDate(value.iterator().next());
                        } else {
                            return false;
                        }
                    } else if (name.equalsIgnoreCase(NNTP_Standard_Article_Headers.From.getValue())) {
                        if (value.size() == 1) { // The From header must be single-valued
                            return isValidUnstructuredValue(value.iterator().next());
                        } else {
                            return false;
                        }
                    } else if (name.equalsIgnoreCase(NNTP_Standard_Article_Headers.References.getValue())) {
                        if (value.size() == 1) {    // The References header must be single-valued
                            return MessageId.isValid(value.iterator().next());
                        } else {
                            return false;
                        }
                    } else if (name.equalsIgnoreCase(NNTP_Standard_Article_Headers.Path.getValue())) {
                        if (value.size() == 1) {    // The Path header must be single-valued
                            return isValidPath(value.iterator().next());
                        } else {
                            return false;
                        }
                    } else if (name.equalsIgnoreCase(NNTP_Standard_Article_Headers.Bytes.getValue())) {
                        if (value.size() == 1) {    // The Bytes header must be single-valued
                            try {
                                return Integer.parseInt(value.iterator().next()) > 0;   // Bytes header value must be a valid positive number
                            } catch (NumberFormatException e) {
                                return false;
                            }
                        } else {
                            return false;
                        }
                    } else if (name.equalsIgnoreCase(NNTP_Standard_Article_Headers.Lines.getValue())) {
                        if (value.size() == 1) {    // The Lines header must be single-valued
                            try {
                                return Integer.parseInt(value.iterator().next()) > 0;   // Lines header value must be a valid positive number
                            } catch (NumberFormatException e) {
                                return false;
                            }
                        } else {
                            return false;
                        }
                    } else {    // not a standard header name
                        // just check that the header value is ok
                        for (String v : value) {
                            if (!isValidHeaderValue(v)) {
                                return false;
                            }
                        }
                        return true;
                    }
                } else {
                    // not a valid header name
                    return false;
                }
                return true;
            }

            /**
             * Check if the header name is valid.
             * <p>
             * Header names must consist of one or more printable US-ASCII characters, excluding the colon character.
             *
             * @param name
             * @return
             */
            public static boolean isValidHeaderName(String name) {
                return name != null                             // not null
                        && !name.isEmpty()                      // not empty
                        && (!name.contains(" ") || name.length() == name.trim().length())    // no leading or trailing spaces (because they're of no use and insidiously deceptive)
                        && (!name.contains(":")                 // must not contain a colon (except for :bytes and :lines)
                        || name.contains(NNTP_Standard_Article_Headers.Bytes.getValue())
                        || name.contains(NNTP_Standard_Article_Headers.Lines.getValue()))
                        && StringUtils.isAsciiPrintable(name);  // all characters must be printable ASCII
            }

            public static boolean isValidHeaderValue(String value) {
                return value != null
                        && !value.isEmpty()
                        && !value.contains("\t")    // no tabs
                        && !value.contains("\r\n");   // no CRLFs
            }

            /**
             * Check if the string is unstructured.
             * According to RFC 5536 and RFC 5322, Unstructured is defined as a sequence of
             * - printable ASCII characters, spaces, and tabs, optionally including folded lines
             * (where long headers are split using CRLF followed by whitespace).
             * However, despite being called "unstructured" it still follows specific formatting rules:
             * It must contain at least one non-whitespace character.
             * It may include folding (line breaks) using CRLF followed by whitespace (FWS), but this is typically used for long headers.
             * It excludes control characters except for whitespace used in folding.
             *
             * @param s
             * @return
             */
            public static boolean isValidUnstructuredValue(String s) {
                return s != null
                        && !s.isEmpty()
                        && s.matches(".*\\p{Print}.*")   // contains at least one non-whitespace character
                        && s.matches("\\p{Print}+(\\r\\n\\t\\s)*[\\p{Print}\\t\\r\\n]*");
            }

            /**
             * The Date header value must be in the format "Wdy, DD Mon YYYY HH:MM TIMEZONE" and while the use of "GMT" as a time zone is
             * deprecated, it is still widely accepted and must be supported by agents.
             *
             * @param date
             * @return
             */
            public static boolean isValidDate(String date) {
                return date != null
                        && !date.isEmpty()
                        && date.matches("(((Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(0[1-9]|[12][0-9]|3[01]|[1-9]))\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s([0-9]{2,4})\\s([0-9]{2}):([0-9]{2})(:([0-9]{2}))?(\\s(GMT|UTC|Z|[+|\\-][0-9]{4}))?\\s?");
            }

            /**
             * Checks if the specified path contains the given identity as one of its components.
             * A path is a sequence of components separated by the "!" character, and the method
             * verifies whether any component of the path matches the given identity.
             *
             * @param path the Path header value to search within; can be null or empty but must be valid if non-null
             * @param identity the identity to search for within the components of the path; can be null or empty
             * @return true if the identity is found as a component of the path, false otherwise
             */
            public static boolean pathContainsIdentity(String path, String identity) {
                if (path != null && identity != null && !identity.isEmpty() && !path.isEmpty() && isValidPath(path)) {
                    String[] pathComponents = path.split("!", -1);
                    for (String pathComponent : pathComponents) {
                        if (pathComponent.equals(identity)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            /**
             * Validates a Path header value according to RFC 5536 Section 3.1.4.
             *
             * According to RFC 5536, the Path header field records the route that the article
             * took to reach the current system. The format is:
             *
             * path = "Path:" SP *WSP path-list tail-entry *WSP CRLF
             * path-list = *( path-identity [FWS] [path-diagnostic] "!" )
             * path-identity = dot-atom-text
             * path-diagnostic = diag-match / diag-other
             * tail-entry = path-identity / path-diagnostic
             *
             * Where:
             * - path-identity: A dot-atom-text representing the system identifier (e.g., "news.example.com")
             * - path-diagnostic: Optional diagnostic information (UTF-8 text without "!")
             * - tail-entry: The final component, either a path-identity or path-diagnostic
             *
             * The path consists of a series of system identifiers separated by "!" exclamation marks.
             * Each system that processes the article prepends its identifier to the path.
             *
             * Examples of valid paths according to RFC 5536:
             * - "not-for-mail" (common tail-entry for posted articles)
             * - "news.example.com!not-for-mail"
             * - "reader.example.net!news.example.com!not-for-mail"
             * - "site1!site2!site3" (UUCP-style)
             *
             * @param path the Path header value to validate (without the "Path:" prefix)
             * @return true if the path is valid according to RFC 5536, false otherwise
             */
            public static boolean isValidPath(String path) {
                if (path == null || path.isEmpty()) {
                    return false;
                }

                // Trim leading and trailing whitespace (allowed by *WSP in ABNF)
                path = path.trim();

                // Path must not be empty after trimming
                if (path.isEmpty()) {
                    return false;
                }

                // Split by "!" to get path components
                // According to RFC 5536, each component before "!" is a path-identity (optionally with path-diagnostic)
                // The last component is the tail-entry
                String[] components = path.split("!", -1); // -1 to preserve trailing empty strings

                // Must have at least one component (tail-entry)
                if (components.length == 0) {
                    return false;
                }

                // Validate each component
                for (int i = 0; i < components.length; i++) {
                    String component = components[i];
                    boolean isTailEntry = (i == components.length - 1 && 0 < i);

                    // Trim whitespace from component (FWS is allowed between components)
                    component = component.trim();

                    // Empty components are not allowed (indicates consecutive "!!" or leading/trailing "!")
                    if (component.isEmpty()) {
                        return false;
                    }

                    // For components in the path-list (all except tail-entry), they should be path-identity
                    // The tail-entry can be either path-identity or path-diagnostic
                    if (!isTailEntry) {
                        // Must be a valid path-identity (dot-atom-text)
                        if (!isValidPathIdentity(component)) {
                            return false;
                        }
                    } else {
                        // Tail-entry: can be path-identity or path-diagnostic
                        // Try path-identity first (more restrictive)
                        if (isValidPathIdentity(component)) {
                            // Valid path-identity
                            continue;
                        }

                        // If not a valid path-identity, check if it's a valid path-diagnostic
                        // path-diagnostic is more permissive - allows UTF-8 characters except "!"
                        // Since we split by "!", we already know there's no "!" inside
                        if (!isValidPathDiagnostic(component)) {
                            return false;
                        }
                    }
                }

                return true;
            }

            /**
             * Checks if a string is a valid path-identity according to RFC 5536.
             *
             * A path-identity is defined as dot-atom-text in RFC 5536, which means:
             * - One or more atext characters separated by dots
             * - atext = ALPHA / DIGIT / "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" /
             *           "-" / "/" / "=" / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~"
             *
             * For practical purposes and compatibility with existing implementations,
             * we use a more restrictive pattern that matches typical system identifiers:
             * letters, digits, dots, hyphens, and underscores.
             *
             * According to RFC 5322 (referenced by RFC 5536):
             * - Cannot start or end with a dot
             * - Cannot have consecutive dots
             *
             * @param component the component to validate as a path-identity
             * @return true if the component is a valid path-identity
             */
            private static boolean isValidPathIdentity(String component) {
                if (component == null || component.isEmpty()) {
                    return false;
                }

                // dot-atom-text constraints from RFC 5322:
                // Cannot start or end with a dot
                if (component.startsWith(".") || component.endsWith(".")) {
                    return false;
                }

                // Cannot have consecutive dots
                if (component.contains("..")) {
                    return false;
                }

                // Must consist of valid atext characters and dots
                // For practical implementation, we limit to: letters, digits, dots, hyphens, underscores
                // This matches typical system identifiers and FQDN formats
                // Pattern: one or more of [a-zA-Z0-9._-]
                if (!component.matches("^[a-zA-Z0-9._-]+$")) {
                    return false;
                }

                // Additional validation: ensure it's not just dots/hyphens/underscores
                // Must contain at least one alphanumeric character
                if (!component.matches(".*[a-zA-Z0-9].*")) {
                    return false;
                }

                return true;
            }

            /**
             * Checks if a string is a valid path-diagnostic according to RFC 5536.
             *
             * A path-diagnostic is optional diagnostic information that can appear in the path.
             * According to RFC 5536:
             * - path-diagnostic = diag-match / diag-other
             * - diag-match = "(" dot-atom-text ")"
             * - diag-other = <any UTF-8 character except "!">
             *
             * Since we split by "!", we know there's no "!" inside the component.
             * We need to validate that it contains valid UTF-8 characters.
             *
             * For the tail-entry, path-diagnostic allows more flexibility than path-identity,
             * including phrases like "not-for-mail" or diagnostic information.
             *
             * @param component the component to validate as a path-diagnostic
             * @return true if the component is a valid path-diagnostic
             */
            private static boolean isValidPathDiagnostic(String component) {
                if (component == null || component.isEmpty()) {
                    return false;
                }

                // path-diagnostic should not contain "!" (already ensured by split)
                // Should consist of printable characters (ASCII or UTF-8)
                // Allow letters, digits, spaces, and common punctuation (but not "!")

                // For practical implementation and security, we'll be somewhat restrictive
                // but allow common diagnostic strings like "not-for-mail"
                // Pattern: printable ASCII characters and basic punctuation, no control characters
                if (!component.matches("^[\\p{Print}\\p{L}\\p{N}._-]+$")) {
                    return false;
                }

                return true;
            }
        }
    }
}
